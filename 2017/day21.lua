rule = {{"../..",".../#.#/..."},
{"#./..","..#/..#/#.."},
{"##/..",".../#../..#"},
{".#/#.","#../.../..."},
{"##/#.","#.#/.#./#.."},
{"##/##","..#/#.#/..#"},
{".../.../...",".#../#..#/#.../.#.."},
{"#../.../...","..##/..##/.#.#/...."},
{".#./.../...","..##/..##/.###/##.."},
{"##./.../...","..../.##./#.##/..#."},
{"#.#/.../...","####/#.##/#.##/#.#."},
{"###/.../...","#..#/..#./..../##.#"},
{".#./#../...","..#./.#../...#/#.##"},
{"##./#../...","..../#.##/#..#/.#.."},
{"..#/#../...","##.#/####/###./###."},
{"#.#/#../...","..../#.##/.###/#.#."},
{".##/#../...","..#./##.#/####/..##"},
{"###/#../...","..#./.##./...#/..#."},
{".../.#./...",".###/#.../.#../####"},
{"#../.#./...","###./.#.#/#.##/##.#"},
{".#./.#./...","..##/..#./###./..#."},
{"##./.#./...","#..#/..#./###./...#"},
{"#.#/.#./...","#.../##.#/#.##/#..#"},
{"###/.#./...","...#/#..#/####/##.#"},
{".#./##./...","#.##/#.##/..../#.#."},
{"##./##./...","..##/###./..#./####"},
{"..#/##./...","..../##../##.#/.##."},
{"#.#/##./...","##../####/####/.#.#"},
{".##/##./...","..../##.#/.###/##.."},
{"###/##./...",".#../#.#./.#../..##"},
{".../#.#/...","####/#.#./..##/#..#"},
{"#../#.#/...",".#../.#../#..#/...."},
{".#./#.#/...","..##/.##./####/#.#."},
{"##./#.#/...","..#./###./.#../...."},
{"#.#/#.#/...","..#./..#./...#/#..."},
{"###/#.#/...","###./.#../##../####"},
{".../###/...","#.##/####/####/..##"},
{"#../###/...",".#.#/...#/###./...#"},
{".#./###/...","..../.#.#/.#../...."},
{"##./###/...","...#/.###/..../.##."},
{"#.#/###/...","..##/###./.#../#..#"},
{"###/###/...",".###/..#./..#./.###"},
{"..#/.../#..",".##./###./####/#.#."},
{"#.#/.../#..","####/#.../#.../..##"},
{".##/.../#..","###./#..#/..#./.#.."},
{"###/.../#..",".###/.##./#.#./.###"},
{".##/#../#..","##.#/...#/.#.#/...#"},
{"###/#../#..","#.##/..#./..../#..#"},
{"..#/.#./#..","#..#/##.#/.##./####"},
{"#.#/.#./#..","###./..##/#..#/#..#"},
{".##/.#./#..",".#../..../...#/...#"},
{"###/.#./#..",".#../##../.###/..#."},
{".##/##./#..","##../..##/##../##.#"},
{"###/##./#..","#.##/#..#/.###/####"},
{"#../..#/#..","##.#/####/#.../..##"},
{".#./..#/#..","#..#/..../..../###."},
{"##./..#/#..","#..#/##.#/##.#/#.#."},
{"#.#/..#/#..",".###/##.#/####/#..."},
{".##/..#/#..","####/.##./...#/#..#"},
{"###/..#/#..",".#.#/####/##.#/...#"},
{"#../#.#/#..","..##/.##./..##/##.."},
{".#./#.#/#..","#.../##../..##/..#."},
{"##./#.#/#..","...#/##.#/#..#/.#.."},
{"..#/#.#/#..","#.#./##../#.##/###."},
{"#.#/#.#/#..","##../##.#/#.#./...."},
{".##/#.#/#..","####/...#/####/.#.."},
{"###/#.#/#..","..../.#../.#../...."},
{"#../.##/#..",".#.#/..#./#..#/.###"},
{".#./.##/#..","#.../.#.#/.###/.##."},
{"##./.##/#..","#.#./#.#./.#../###."},
{"#.#/.##/#..","####/##../.##./####"},
{".##/.##/#..","#.../#.#./#.##/###."},
{"###/.##/#..","####/####/..../####"},
{"#../###/#..","####/.##./...#/##.#"},
{".#./###/#..",".#../#.##/#..#/..##"},
{"##./###/#..","#.#./..##/#.../..##"},
{"..#/###/#..","#.##/.###/#.#./###."},
{"#.#/###/#..","#.##/#.##/..../#..#"},
{".##/###/#..",".##./#.#./..##/####"},
{"###/###/#..",".##./#..#/#.../###."},
{".#./#.#/.#.","#.#./#..#/#..#/##.#"},
{"##./#.#/.#.","...#/#.#./##.#/###."},
{"#.#/#.#/.#.","##.#/..##/##.#/#.##"},
{"###/#.#/.#.",".#.#/..#./##../.##."},
{".#./###/.#.","#..#/..#./..##/#..."},
{"##./###/.#.","####/.#.#/####/..#."},
{"#.#/###/.#.","#.#./..##/##../#..#"},
{"###/###/.#.","...#/..../..../#.#."},
{"#.#/..#/##.","..#./.##./###./.#.#"},
{"###/..#/##.","#.../###./...#/####"},
{".##/#.#/##.","..../..../.###/##.."},
{"###/#.#/##.","##../..../#.#./.##."},
{"#.#/.##/##.",".#.#/##../..##/#.#."},
{"###/.##/##.","###./####/...#/.#.."},
{".##/###/##.","..##/#.../..##/.#.#"},
{"###/###/##.","..##/...#/.###/.#.."},
{"#.#/.../#.#","..##/#.../##.#/...."},
{"###/.../#.#","#.##/#..#/..../##.."},
{"###/#../#.#","#.../..../##.#/..#."},
{"#.#/.#./#.#","###./..##/.#../.##."},
{"###/.#./#.#","..../#..#/.###/#..#"},
{"###/##./#.#",".#.#/###./##.#/.###"},
{"#.#/#.#/#.#","..../..../.##./#..#"},
{"###/#.#/#.#",".###/.#.#/...#/.###"},
{"#.#/###/#.#",".#.#/##../.#../.#.."},
{"###/###/#.#",".#.#/.##./#.##/...."},
{"###/#.#/###","..#./..#./..#./..##"},
{"###/###/###","##.#/..##/.#.#/...."}}
input = {".#.",
"..#",
"###"}
historic = {}
art = {}
for i = 1, 3 do
    if not art[i] then art[i] = {} end
    for j = 1, 3 do
        local str = string.sub(input[j],i,i)
        if str == "#" then
            art[i][j] = 1
        else
            art[i][j] = 0
        end
    end
end
function debugprint(art) -- print a art (debug)
    local poi = ""
    for i = 1, #art do
        poi = poi .. "-"
    end
    print(poi)
    for y = 1, #art do
        local str = ""
        for x = 1, #art do
            if not art[x] then art[x] = {} end
            if art[x][y] == 1 then
                str = str .. "#"
            elseif art[x][y] == 0 then
                str = str .. "."
            else
                str = str .. "o"
            end
        end
        print(str)
    end
end
function copy(art) -- copy a art (so a change made on it don't affect the original)
    local nart = {}
    for x = 1, #art do
        if not nart[x] then nart[x] = {} end
        for y = 1, #art do
            nart[x][y] = art[x][y]
        end
    end
    return nart
end
--[[credits to
    https://www.geeksforgeeks.org/inplace-rotate-square-matrix-by-90-degrees/
    https://www.geeksforgeeks.org/rotate-matrix-90-degree-without-using-extra-space-set-2/
--]]
function artbreak(art,n) -- break a art in multiple small arts (and also enchant now)
    local max = #art/n
    local t = {}
    for i = 1, max do
        for j = 1, max do
            local nart = {}
            for x = n*(i - 1) + 1, n*i do
                local xr = (x - 1)%n + 1
                if not nart[xr] then nart[xr] = {} end
                for y = n*(j - 1) + 1, n*j do
                    local yr = (y - 1)%n + 1
                    nart[xr][yr], art[x][y] = art[x][y], nil
                end
            end
            table.insert(t,nart)
        end
    end
    return t
end
function trans(input)
    if input == 0 then
        return "."
    elseif input == 1 then
        return "#"
    elseif input == "." then
        return 0
    elseif input == "#" then
        return 1
    else
        return input
    end
end
function tosimplyfied(art) --convert a art to simplified version
    local str = ""
    for i = 1, # art do
        for j = 1, # art do
            if (j == #art) and (i < #art) then
                str = str .. trans(art[j][i]) .. "/"
            else
                str = str .. trans(art[j][i])
            end
        end
    end
    return str
end
function toart(simp) --convert simplified version to art
    local t1 = {}
    local i = 1
    local bar = string.find(simp, "/", i)
    while bar do
        local t2 = {}
        local str = string.sub(simp, i, bar - 1)
        for j = 1, #str do
            local fstr = string.sub(str, j, j)
            table.insert(t2,trans(fstr))
        end
        table.insert(t1,t2)
        i = bar + 1
        bar = string.find(simp, "/", i)
    end
    local t2 = {}
    local str = string.sub(simp, i, #simp)
    for j = 1, #str do
        local fstr = string.sub(str, j, j)
        table.insert(t2,trans(fstr))
    end
    table.insert(t1,t2)
    for x = 1, #t1 do
        for y = x, #t1 do
            t1[x][y], t1[y][x] = t1[y][x], t1[x][y]
        end
    end
    return t1
end
function tm1(t1,t2) -- merges type 1
    for i = 1, #t1 do
        for j, s in pairs(t2[i]) do
            table.insert(t1[i],s)
        end
    end
    t2 = nil
end
function tm2(t1,t2) -- merges type 2
    local size = #t1
    for i = #t1 + 1, #t1 + #t2 do
        t1[i] = t2[i - size]
    end
    t2 = nil
end
function rotate(art) -- rotate a art anti - clockwize
    --transpose
    for x = 1, #art do
        for y = x, #art do
            art[x][y], art[y][x] = art[y][x], art[x][y]
        end
    end
    --invert column
    for x = 1, #art do
        for y = 1,#art/2 do
            art[x][y], art[x][#art + 1 - y] = art[x][#art + 1 - y], art[x][y]
        end
    end
end
function flip(art) -- flip a art
    for x = 1, #art/2 do
        for y = 1, #art do
            art[x][y], art[#art + 1 - x][y] = art[#art + 1 - x][y], art[x][y]
        end
    end
end
function enchantaux(simp,s)
    return simp == s
end
function enchant(art)
    --[[
        art1 = 0
        art2 = 0F
        art3 = 90
        art4 = 90F
        art5 = 180
        art6 = 180F
        art7 = 270
        art8 = 270F
    --]]
    local eartsimp
    attempt = 0
    repeat
        local sart = tosimplyfied(art)
        for i, s in pairs(rule) do
            if enchantaux(s[1], sart) then
                eartsimp = s[2]
                break
            else
                flip(art)
                sart = tosimplyfied(art)
                if enchantaux(s[1], sart) then
                    eartsimp = s[2]
                    break
                else
                    flip(art)
                end
            end
        end
        rotate(art)
        attempt = attempt + 1
        if attempt == 5 then return false end 
    until eartsimp
    return toart(eartsimp)
end
function artjoin(list) -- join multiples art in one
    local max = math.sqrt(#list) -- simetry, also n^2 = #list
    local nart
    k = 0
    for i = 1, max do
        local nsart
        for j = 1, max do
            if not nsart then
                k = k + 1
                nsart = list[k]
            else
                k = k + 1
                tm1(nsart,list[k])
            end
        end
        if not nart then
            nart = nsart
        else
            tm2(nart,nsart)
        end
    end
    return nart
end
function count(art) -- count how many pixels on a art have
    local count = 0
    for i = 1, #art do
        for j = 1, #art do
            if art[i][j] == 1 then
                count = count + 1
            end
        end
    end
    return count
end
for i = 1, 5 do
    if #art % 2 == 0 then
        list = artbreak(art,2)
    elseif #art % 3 == 0 then
        list = artbreak(art,3)
    end
    for i, s in pairs(list) do
        list[i] = enchant(s)
    end
    art = artjoin(list)
    if i == 5 then
        print("part I")
        print("there has " .. count(art) .. " activated pixels")
    end
end
--part II
function arttype3(M) --return a "type" of a art 3 x 3
    local type = 0
    if not (#M == 3) then return 0 end --must be 3x3 (reasons idk)
    for x = 1, 3 do
        for y = 1, 3 do
            type = type + M[x][y]*8^(y - 1)*2^(x - 1)
        end
    end
    return type
end
--[[this is you input :^)
    art = {{0,0,1},{1,0,1},{0,1,1}}
    debugprint(art)
--]]
function process(art,n,bool)
    for i = 1, n do
        if #art % 2 == 0 then
            list = artbreak(art,2)
        elseif #art % 3 == 0 then
            list = artbreak(art,3)
        end
        for i, s in pairs(list) do
            list[i] = enchant(s)
        end
        for i, s in pairs(list) do
            if not s then return nil end
        end
        if (i == n) and bool then
            return list
        end
        art = artjoin(list)
    end
    return art
end
print("================ test =================")
typelist = {}
typeconnect = {}
--[[
    typelist:
    {[type] = {qtd, value}, ...}
    typelist[type][1] = qtd
    typelist[type][2] = value
    typeconnect:
    {[type] = {[type] = qtd, ...}}
    typeconnect[type][type'] = qtd
--]]
function fill_the_type_connection_list(art, list_1, list_2)
    local type = arttype3(art)
    if list_2[type] then return end
    local t1, t2 = {}, {}
    t1[1], t1[2] = 0, count(art)
    list_2[type] = t1
    local list = process(art, 3, true)
    for i, s in pairs(list) do
        local stype = arttype3(s)
        if not t2[stype] then t2[stype] = 1 else t2[stype] = t2[stype] + 1 end
        fill_the_type_connection_list(s, list_1, list_2)
    end
    list_1[type] = t2
end
fill_the_type_connection_list({{0,0,1},{1,0,1},{0,1,1}},typeconnect,typelist)
--[[
for i = 0, 511 do
    if typelist[i] then
        print("element " .. i)
        print(table.unpack(typelist[i]))
        print("elements connected")
        local connection = typeconnect[i]
        if connection then
            for j, s in pairs(connection) do
                print(j, s)
            end
        end
    end
end
--]]
function getbit(n)
    local count = 0
    if n & 0x1 == 0x1 then count = count + 1 end
    if n & 0x2 == 0x2 then count = count + 1 end
    if n & 0x4 == 0x4 then count = count + 1 end
    if n & 0x8 == 0x8 then count = count + 1 end
    if n & 0x10 == 0x10 then count = count + 1 end
    if n & 0x20 == 0x20 then count = count + 1 end
    if n & 0x40 == 0x40 then count = count + 1 end
    if n & 0x80 == 0x80 then count = count + 1 end
    if n & 0x100 == 0x100 then count = count + 1 end
    return count
end
simulation = {}
init = arttype3({{0,0,1},{1,0,1},{0,1,1}})
print("initial " .. init)
for i = 0, 511 do
    if not simulation[i] then simulation[i] = {} end
    if i == init then
        simulation[i][1] = 1
    else
        simulation[i][1] = 0
    end
    simulation[i][2] = getbit(i)
end
--[[
for i = 0, 511 do
    print("element " .. i)
    print(table.unpack(simulation[i]))
end
--]]
for i = 1, 6 do
    local temp = {}
    for i = 0, 511 do
        temp[i] = {}
        temp[i][1] = 0
        temp[i][2] = simulation[i][2]
    end
    for i = 0, 511 do
        local qtd = simulation[i][1]
        if qtd > 0 then
            local connection = typeconnect[i]
            for j, s in pairs(connection) do
                temp[j][1] = temp[j][1] + qtd * s
            end
        end
    end
    for i = 0, 511 do
        simulation[i][1] = temp[i][1]
        simulation[i][2] = temp[i][2]
    end
end
p = 0
for i = 0, 511 do
    p = p + simulation[i][1] * simulation[i][2]
end
print("estimated " .. p .. " activated pixels")
--[[values espexteds
    1 (3): 24
    2 (6): 194
    3 (9): 1736
    4 (12): 15832
    5 (15): 141882
--]]
